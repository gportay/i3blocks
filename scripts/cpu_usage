#!/bin/bash
#
# cpu_temperature - mock up the cpu_temperature module from i3status.
# Copyright (C) 2018  GaÃ«l PORTAY
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

set -e

# Setup default values
full_format="${full_format:-%usage}"
#format_above_threshold is not set
#format_above_degraded_threshold is not set
#path is not set
max_threshold="${max_threshold:-95}"
degraded_threshold="${degraded_threshold:-90}"

procpath="${path:-/proc/stat}"
if ! [ -e "$procpath" ]
then
	echo "cant read cpu usage"
	exit 0
fi

# Set full text format string and color
fulltext_format="$full_format"
color="#ffffff"
extra_json+=",\"color\":\"$color\""

# Compute cpuX placeholder value from procfile (current) and variable (previous)
# user: normal processes executing in user mode
# nice: niced processes executing in user mode
# system: processes executing in kernel mode
# idle: twiddling thumbs
# iowait: waiting for I/O to complete
# irq: servicing interrupts
# softirq: servicing softirqs
while read -a curr_cpu
do
	id="${curr_cpu[0]}"

	# Set prev_cpuX from $cpuX or $currr_cpuX if unset
	eval "$(echo "read -a prev_cpu < <(echo "\${$id:-${curr_cpu[*]}}")")"

	# Compute cpuX placeholder value
	prev_total="$((prev_cpu[1] + prev_cpu[2] + prev_cpu[3] + prev_cpu[4]))"
	curr_total="$((curr_cpu[1] + curr_cpu[2] + curr_cpu[3] + curr_cpu[4]))"
	idle="$((curr_cpu[4] - prev_cpu[4]))"
	total="$((curr_total - prev_total))"
	usage=0
	if [[ $total -ne 0 ]]
	then
		usage="$((((1000 * (total - idle) / total + 5) / 10)))"
	fi
	eval "$(echo "_$id='$(printf "%02d%%" "$usage")'")"

	# Propagate cpu stat
	extra_json+=",\"$id\":\"${curr_cpu[*]}\""
done < <(grep -E "^cpu[0-9]* " "$procpath")

# Compute usage placeholder value
_usage="$_cpu"

# Check for threshold and degraded threshold to update formatted string
if [[ $cpu -ge $max_threshold ]]
then
	color="${color_bad:-#ff0000}"
	fulltext_format="${format_above_threshold:-$full_format}"
elif [[ $cpu -ge $degraded_threshold ]]
then
	color="${color_degraded:-#ffff00}"
	fulltext_format="${format_above_degraded_threshold:-$full_format}"
fi

# Update json and set current cpu stat
eval "$(echo "fulltext=\"${fulltext_format//%/\$_}\"")"
printf '{"full_text":"%s"%s}\n' "$fulltext" "$extra_json"
